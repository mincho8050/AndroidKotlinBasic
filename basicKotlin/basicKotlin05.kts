/*
    컬렉션
    - 개발에 유용한 자료구조
    - 안드로이드 개발에서도 리스트나 맵은 자주 사용되는 자료구조!!
 */


//1) 리스트
// > 리스트는 배열처럼 같은 자료형의 데이터들을 순서대로 가지고 있는 자료구조
// > 중복된 아이템을 가질 수 있고, 추가, 삭제, 교체 등이 쉽습니다.

//요소를 변경할 수 없는 읽기 전용 리스트는 listOf() 메서드로 작성할 수 있습니다.
//val foods : List<String> = listOf("라면","갈비","밥")
//형추론으로 자료형을 생략할 수 있다.
val foods = listOf("라면","갈비","밥")

//요소를 변경하는 리스트를 작성할때는 mutableListOf() 메서드를 사용한다.
//자바와 다른점은 특정 요소에 접근할 때 대괄호 안에 요소 번호로 접근할 수 있다.
val foods2 = mutableListOf("라면","갈비","밥")

foods2.add("초밥") //"초밥"을 맨 뒤에 추가
foods2.removeAt(0) //맨 앞의 아이템 삭제
foods2[1] = "부대찌개"   //foods2.set(1,"부대찌개") > 1번째 아이템을 부대찌개로 변경

for(i in foods2){
    println(i)
}
println(foods2)
println(foods2[0])
println(foods2[1])
println(foods2[2])



//2) 맵
// > 맵은 키(key) 와 값(value)의 쌍으로 이루어진 키가 중복될 수 없는 자료구조
// > 리스트와 마찬가지로 mapOf() 메서드로 읽기 전용 맵을 만들 수 있고,
// > mutableMapOf() 메서드로 수정 가능한 맵을 만들 수 있다.
// > 맵의 요소에 접근할 때는 대괄호 안에 키(key)를 요소명으로 작성하여 접근한다

//읽기 전용 맵
val map = mapOf("a" to 1, "b" to 2, "c" to 3)

//변경 가능한 맵
val citiesMap = mutableMapOf("한국" to "서울", "일본" to "동경", "중국" to "북경")
//요소에 덮어쓰기
citiesMap["한국"]="서울특별시"
//추가
citiesMap["미국"]="워싱턴"

//맵 전체의 키와 값을 탐색할 때는 다음과 같이 간단히 탐색할 수 있다.
for ((k,v) in citiesMap){
    println("$k -> $v")
}




//3) 집합
// > 집합(set)은 중복되지 않는 요소들로 구성된 자료구조
// > setOf() 메서드로 읽기 전용 집합 / mutableSetOf() 메서드로 수정 가능한 집합을 생성

//읽기 전용 집합
val citySet = setOf("서울","수원","부산")

//수정 가능한 집합
val citySet2= mutableSetOf("서울","수원","부산")
citySet2.add("안양") //"안양"추가
println(citySet2)
citySet2.remove("수원") //"수원" 제거
println(citySet2)

//집합의 크기
println(citySet2.size) //3
//"서울이 집합에 포함되어있는지?
println(citySet2.contains("서울")) //boolean형!




//------------------------------------------------------------------------------------------------------------------



/*
    람다식
    - 코틀린은 자바 8과 같이 람다식을 지원.
    - 람다식은 하나의 함수를 표현하는 방법으로,
    - 익명 클래스나 익명 함수를 간결하게 표현할 수 있어서 매우 유용하다.
    - 람다식은 코드를 간결하게 해주는 장점이 있지만 디버깅이 어렵고 남발할 경우 오히려 코드 가독성이 떨어진다
 */

//먼저 두 수를 인수로 받아서 더해주는 add()메서드
//fun add( x : Int , y : Int) : Int {
//    return x + y
//}
// > 반환 자료형을 생략하고 블록과 return을 생략
//fun add(x:Int,y:Int) = x+y
// > 또한 코틀린의 람다식은 다음과 같이 항상 중괄호로 둘러 싸여 있다.
// > 내용으로는 인수 목록을 나열하고 -> 이후에 본문이 위치한다.
// > 람다식을 변수에 저장할 수 있고 이러한 변수는 일반 함수처럼 사용할 수 있다.
//{인수1:타입1,인수2:타입2 -> 본문}
var add = {x:Int,y:Int -> x + y}
println(add(2,5))




//1) SAM 변환
// > 코틀린에서는 추상 메서드 하나를 인수로 사용할 때는 함수를 인수로 전달하면 편하다.
// > 자바로 작성된 메서드가 하나인 인터페이스를 구현할 때는 대신 함수를 작성할 수 있다.
// > 이를 SAM(Single Abstract Method)변환이라고 한다

// > SAM 변환의 예를 안드로이드에서 들어본다.
// > 안드로이드에서는 버튼의 클릭 이벤트를 구현할 때 onClick() 추상 메서드만을 가지고 있는
// > View.OnClickListener 인터페이스를 구현한다.

// 1-1)
// > 다음은 안드로이드에서 버튼에 클릭 이벤트 리스너를 구현하는 코드를 일반적인
// > 익명클래스를 작성하듯 작성한 코드.
// > 여기서 View.OnClickListener 인터페이스에는 onClick() 추상 메서드가 하나 있기 때문에
// > onClick() 메서드를 오버라이드하고 있다.
/*button.setOnClickListener(object : View.OnClickListener){
    override fun onClick(v:View?){
        //클릭시 처리
    }
}*/

// 1-2)
// > 구현하는 인터페이스에 구현해야 할 메서드가 하나뿐일 때는 이를 람다식으로 변경 가능
// > 다음 코드는 람다식으로 변경되어 코드가 줄었지만 괄호도 중첩되어있고 기호도 많고 뭔가 코드가 복잡해보인다
/*button.setOnClickListener({v: View? ->
    //클릭 시 처리
})*/


// 1-3)
// > 메서드 호출 시 맨 뒤에 전달되는 인수가 람다식인 경우에는 람다식을 괄호 밖으로 뺄 수 있다.
// > 다음 코드는 하나의 인수만 있고 람다식이 전달되었기 때문에 마지막 인수라고 볼 수 있다.
/*button.setOnClickListener(){v: View? ->
    //클릭 시 처리
}*/


// 1-4)
// > 그리고 람다가 어떤 메서드의 유일한 인수인 경우에는 메서드의 괄호를 생략할 수 있다.
/*button.setOnClickListener{v: View? ->
    //클릭시 처리
}*/


// 1-5)
// > 컴파일러가 자료형을 추론하는 경우에는 자료형 생략 가능
/*button.setOnClickListener{v ->
    //클릭 시 처리
}*/


// 1-6)
// > 만약 클릭 시 처리에 어떤 코드를 작성했는데, v 인수를 사용하지 않는다면
// > v 라는 이름은 _ 기호로 대치할 수 있다.
// > 인수가 많은 경우에 꼭 사용하는 인수 이외에는 _ 기호로 변경하여 애초에 잘못 사용하는 것을 방지할 수 있다.
// > 이러한 방식은 다른 함수형 언어에서도 적용되는 함수형 언어의 특징 중 하나이다.
/*button.setOnClickListener{_ ->
    //클릭 시 처리
}*/


// 1-7)
// > 그리고 람다식에서 인수가 하나인 경우에는 이를 아예 생략하고 람다 블록 내에서
// > 인수를 it로 접근할 수 있다.
// 다음 코드에서는 it는 View? 타입의 v 인수를 가리킨다.
/*button.setOnClickListener{
    it.visibility = View.GONE
}*/

// > 위 7가지 형태는 모두 같은 결과를 나타내지만 마지막 코드가 가장 읽기 쉽다.
// > 중요한 것은 SAM 변환은 자바에서 작성한 인터페이스일 때만 동작한다.
// > 코틀린에서는 인터페이스 대신에 함수를 사용하는 것이 좋다!






//------------------------------------------------------------------------------------------------------------------





/*
    기타 기능
    - 확장 함수 : 원래 있던 클래스에 기능을 추가하는 함수
    - 형변환 : 숫자형 자료형끼리 쉽게 형변환
    - 형 체크 : 변수의 형이 무엇인지 검사
    - 고차 함수 : 인자로 함수를 전달하는 기능
    - 동반 객체 : 클래스의 인스턴스 생성 없이 사용할 수 있는 객체
    - let() 함수 : 블록에 자기 자신을 전달하고 수행된 결과를 반환하는 함수
    - with() 함수 : 인자로 객체를 받고 블록에서 수행된 결과를 반환하는 함수
    - apply() 함수 : 블록에 자기 자신을 전달하고 이 객체를 반환하는 함수
    - run() 함수 : 익명함수처럼 사용하거나, 블록에 자기 자신을 전달하고 수행된 결과를 반환하는 함수
 */


// 1) 확장 함수
// > 코틀린은 확장 함수 기능을 사용하여 쉽게 기존 클래스에 함수 추가 가능
// > 확장 함수를 추가할 클래스에 점을 찍고 함수 이름을 작성한다.
// > 확장 함수 내부에서는 이 객체를 this로 접근할 수 있고 이러한 객체를 리시버 객체라고 한다.
// > 다음은 Int 자료형에 짝수인지 아닌지를 알 수 있도록 isEven() 확장 함수를 추가한 예시이다.
fun Int.isEven() = this % 2 ==0
val a=5
val b=6
println(a.isEven())
println(b.isEven())
// > 자바에서는 기본 자료형에 기능을 추가하려면 상속을 받고 추가 메서드를 작성해야 했다.
// > String 클래스의 경우 final로 상속이 막혀 있어 이 마저도 불가능.


// 2) 형변환
// > 숫자형 자료형끼리는 to자료형() 메서드를 사용해 형변환 가능
val a2=10L
val b2=20

val c2=a2.toInt() //Long을 Int로
val d2=b2.toDouble() //Int를 Double로
val e2=a2.toString() //Long을 String으로

// > 숫자 형태의 문자열을 숫자로 바꿀 때는 자바와 마찬가지로 Integer.parseInt() 메서드 사용
val intStr="10"
val str2=Integer.parseInt(intStr)

//일반 클래스 간에 형변환을 하려면 as 키워드를 사용
open class Animal
class Dog:Animal()
val dog=Dog()
val animal=dog as Animal    //dog를 Animal형으로 변환



// 3) 형 체크
// > is 키워드를 사용하여 형을 체크할 수 있다.
// > 자바의 instanceOf에 대응한다.
val str3="hello"
if(str3 is String){ //str3이 String형이라면
    println(str3.toUpperCase()) //대문자로 변환
}




// 4) 고차 함수
// > 코틀린에서는 함수의 인수로 함수를 전달하거나 함수를 반환할 수 있다.
// > 이렇게 다른 인수로 받거나 반환하는 함수를 고차함수(higher-order function, 고계함수) 라고 한다

// > 예시는 다음과 같다.
// > add함수는 x,y,callback 세 개의 인수를 받는다.
// > 내용은 callback에 x와 y의 합을 전달한다.
// > 여기서 callback은 하나의 숫자를 받고 반환이 없는 함수이다.
// > 자바에서는 주로 인터페이스를 사용하는데 코틀린은 함수를 활용하는점이 다르다

//인수 : 숫자, 숫자, 하나의 숫자를 인수로 하는 반환값이 없는 함수
fun add(x:Int , y:Int , callback:(sum:Int) -> Unit){
    callback(x+y)
}
//함수는 {}로 감싸고 내부에서는 반환값을 it로 접근할 수 있다.
add(5,3,{ println(it)})




// 5) 동반 객체
// > 프래그먼트는 특수한 제약 때문에 팩토리 메서드를 정의하여 인스턴스를 생성해야 한다.
// > 팩토리 메서드는 생성자가 아닌 메서드를 사용해 객체를 생성하는 코딩 패턴을 말하는데,
// > 클래스와 별개로 보며 포함 관계도 아니다.
// > 코틀린에서는 자바의 static과 같은 정적인 메서드를 만들 수 있는 키워드를 제공하지 않는다.
// > 대신 동반 객체(companion object)로 이를 구현한다.

//다음 코드는 newInstance() 정적 메서드를 사용해서 Fragment 객체를 생성하는 팩토리 패턴을 구현 및 사용 예
/*class Fragment{
    companion object{
        fun newInstance() : Fragment {
            println("생성됨")
        }
    }
}
val fragment = Fragment.newInstance()*/



// 6) let() 함수
// > 코틀린 기본 라이브러리는 몇 가지 유용한 함수를 제공한다.
// > let() 함수는 블록에 자기 자신을 인수로 전달하고 수행된 결과를 반환한다.
// > 인수로 전달한 객체는 it으로 참조한다.
// > let() 함수는 안전한 호출 연산자 ?. 와 함께 사용하면 null값이 아닐 때만 실행하는 코드를 다음과 같이 나타냄

//fun <T,R> T.let(block: (T) -> R) : R
val str6= "10"
val result = str6?.let{ //Int
    Integer.parseInt(it)
}
println(result+1)
// > 이 코드는 str6가 null이 아닐 때만 정수로 변경하여 출력하는 코드.
// > 복잡한 if문을 대체할 수 있다.


// 7) with() 함수
// > 인수로 객체를 받고 블록에 리시버 객체로 전달한다. 그리고 수행된 결과를 반환
// > 리시버 객체로 전달된 객체는 this로 접근할 수 있다.
// > this는 생략이 가능하므로 다음과 같이 작성할 수 있다.
// > 안전한 호출이 불가능하여!! str7이 null값이 아닌 경우에만 사용해야 한다.
val str7="hello"
with(str7){
    println(toUpperCase())
}



// 8) apply() 함수
// > 블록에 객체 자신이 리시버 객체로 전달되고 이 객체가 반환
// > 객체의 상태를 변화시키고 그 객체를 다시 반환할 때 주로 사용한다.
//fun <T> T.apply(block: T.() -> Unit) : T
/*val result8=car?.apply{
    car.setColor(Color.RED)
    car.setPrice(1000)
}*/



// 9) run() 함수
// > 익명 함수처럼 사용하는 방법과, 객체에서 호출하는 방법을 모두 제공한다.
// > 익명 함수처럼 사용할 때는 블록의 결과를 반환한다.
// > 블록안에 선언된 변수는 모두 임시로 사용되는 변수
// > 이렇게 복잡한 계산에 임시변수가 많이 필요할 때 유용하다.

//fun <R> run(block:() -> R) : R
val avg=run{
    val korean=100
    val english=80
    val math=50

    (korean+english+math)/3.0
}
//객체에서 호출하는 방법은 객체를 블록의 리시버 객체로 전달하고 블록의 결과를 반환한다.
//안전한 호출을 사용할 수 있어서 with() 함수보다는 더 유용하다
//fun <T,R> T.run(block: T.() -> R) : R
str7?.run{
    println(toUpperCase())
}





