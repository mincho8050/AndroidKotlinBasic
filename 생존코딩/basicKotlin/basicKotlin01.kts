
/*
    변수와 상수
    변수 : var > 값을 변경할 수 있음
    상수 : val > 자바의 final과 같음 > 값 변경 안됨
 */
/*var a=10
val b=20
a=30*/
//b=2 > 오류! 상수기때문에


/*
    함수
    - fun 함수명(인수1:자료형1,인수2:자료형2):반환자료형
    - 코틀린에서는 반환값이 없을 때 Unit형을 사용한다 > 자바의 void에 대응
 */
fun greet(str:String): Unit {
    println(str)
}

greet("안녕")

/*
    기본자료형
    - 코틀린의 기본 자료형은 모두 객체이다
    - 자바가 프리미티브 자료형(int,double 등) 과 객체자료형으로 분류되는 것과 다르다.
 */

/*
    숫자형
    Double
    Float > f
    Long  > L
    Int
    Short
    Byte
    -리터럴이란 자료형을 알 수 있는 표기 형식
    -리터럴에 따라 코틀린 컴파일러는 자료형 추론
 */

var a=10
var b=10L
var c=10.0
var d=10.0f

/*
    문자형
    String : ""
    Char    : ''
 */
var str="안녕하세요"
var char='안'

//여러 줄의 문자열 표현할 때는 큰 따옴표 3개를 리터럴로 사용한다.
//여러 줄에 걸친 문자열을 작성할 때 편리합니다
var str1="""
    오늘은
    날씨가 좋습니다.
    빨래를 합시다.
    """

//문자열 비교는 ==을 사용한다. 자바의 equals() 메서드와 대응한다
//자바에서는 오브젝트 비교 시에 == 사용하는데,
//코틀린에서 오브젝트 비교 시에는 ===를 사용합니다
str="hello"
if(str=="hello"){
    println("안녕하세요")
}else{
    println("안녕 못해요")
}

//문자열 템플릿
//자바와 같이 + 기호로 문자열을 연결할 수 있다.
// $기호를 사용하면 문자열 리터럴 내부에 변수를 쉽게 포함 할 수 있다
var str2="안녕"
println(str2+"하세요") //자바

//코틀린
println("$str2 하세요")
println("${str2}하세요")


/*
    배열
    - Array라는 별도의 타입으로 표현
    - arrayOf() 메서드를 사용하여 배열의 생성과 초기화를 함께 수행한다.
    - 컴파일러가 자료형을 유추할 수 있을 때는 이를 생략가능
    - 배열의 요소에 접근하는 것은 대과호 안에 요소 번호를 지정하는 것으로 자바와 동일
 */
val numbers:Array<Int> = arrayOf(1,2,3,4,5)
val numbers2 = arrayOf(1,2,3,4,5) //자료형 생략
numbers[0] = 5 //[5,2,3,4,5]


